name: Generate Plugin Details

on:
  push:
    branches:
      - main
    paths:
      - 'plugins.json'
  schedule:
    - cron: '0 0 */2 * *'
  workflow_dispatch:

jobs:
  generate-details:
    runs-on: ubuntu-latest
    permissions:
        contents: write
        issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN  }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @actions/core

      - name: Generate plugin details
        id: generate
        run: |
          node <<'EOL'
          const fs = require('fs');
          const https = require('https');
          const core = require('@actions/core');

          async function main() {
            try {
              console.log('ğŸš€ å¼€å§‹ç”Ÿæˆæ’ä»¶è¯¦æƒ…...');
              console.log('æ­£åœ¨è¯»å– plugins.json æ–‡ä»¶...');
              const plugins = JSON.parse(fs.readFileSync('plugins.json', 'utf8'));
              console.log(`âœ… æˆåŠŸè¯»å– plugins.jsonï¼Œå‘ç° ${plugins.length} ä¸ªæ’ä»¶`);

              // è¯»å–ç°æœ‰çš„ plugin_details.json ä»¥ä¿ç•™ createdAt æ—¶é—´
              let existingDetails = new Map();
              if (fs.existsSync('plugin_details.json')) {
                console.log('å‘ç°ç°æœ‰çš„ plugin_details.jsonï¼Œæ­£åœ¨è¯»å–...');
                const oldDetails = JSON.parse(fs.readFileSync('plugin_details.json', 'utf8'));
                for (const detail of oldDetails) {
                  existingDetails.set(detail.id, detail.createdAt);
                }
                console.log(`âœ… æˆåŠŸè¯»å– ${existingDetails.size} ä¸ªç°æœ‰æ’ä»¶çš„åˆ›å»ºæ—¶é—´`);
              }

              // è·³è¿‡ç¬¬ä¸€ä¸ªæ’ä»¶
              const pluginsToProcess = plugins.slice(1);
              console.log(`å‡†å¤‡å¤„ç† ${pluginsToProcess.length} ä¸ªæ’ä»¶ï¼ˆè·³è¿‡ç¬¬ä¸€ä¸ªï¼‰`);

              const pluginDetails = [];
              const errors = [];

              for (const plugin of pluginsToProcess) {
                try {
                  console.log(`\n=== æ­£åœ¨è·å–æ’ä»¶æ¸…å•ï¼š${plugin.id} ===`);
                  console.log(`ä»“åº“åœ°å€ï¼š${plugin.repositoryUrl}`);
                  const manifest = await fetchManifest(plugin.repositoryUrl);
                  
                  const createdAt = existingDetails.get(plugin.id) || new Date().toISOString();

                  pluginDetails.push({
                    id: plugin.id,
                    manifest: manifest,
                    createdAt: createdAt
                  });
                  
                  console.log(`âœ… æˆåŠŸå¤„ç†æ’ä»¶ï¼š${plugin.id}`);
                } catch (error) {
                  const errorMsg = `æ’ä»¶ ${plugin.id} å¤„ç†å¤±è´¥ï¼š${error.message}`;
                  console.error(`âŒ ${errorMsg}`);
                  errors.push(errorMsg);
                  // ç»§ç»­å¤„ç†å…¶ä»–æ’ä»¶ï¼Œä¸ä¸­æ–­æ•´ä¸ªæµç¨‹
                }
              }

              // å†™å…¥ plugin_details.json æ–‡ä»¶
              fs.writeFileSync('plugin_details.json', JSON.stringify(pluginDetails, null, 2));
              console.log(`\nâœ… ç”Ÿæˆ plugin_details.json æ–‡ä»¶ï¼ŒåŒ…å« ${pluginDetails.length} ä¸ªæ’ä»¶`);

              // ç”Ÿæˆ commit message
              let commitMessage = `è‡ªåŠ¨ç”Ÿæˆ plugin_details.json`;
              if (pluginDetails.length > 0) {
                const pluginNames = pluginDetails.map(p => p.id).slice(0, 5).join(', ');
                commitMessage += `\n\næ›´æ–°äº† ${pluginDetails.length} ä¸ªæ’ä»¶ï¼ŒåŒ…æ‹¬ï¼š${pluginNames}`;
                if (pluginDetails.length > 5) {
                  commitMessage += ' ç­‰...';
                }
              }
              // å°† commit message å†™å…¥ GITHUB_OUTPUT
              const commitMessageKey = 'commit_message';
              const eofMarker = `EOF_${Math.random().toString(36).substring(2, 15)}`;
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `${commitMessageKey}<<${eofMarker}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `${commitMessage}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `${eofMarker}\n`);


              // æŠ¥å‘Šé”™è¯¯ç»Ÿè®¡
              if (errors.length > 0) {
                console.warn(`\nâš ï¸  å¤„ç†è¿‡ç¨‹ä¸­å‘ç° ${errors.length} ä¸ªé”™è¯¯ï¼š`);
                errors.forEach((error, index) => {
                  console.warn(`${index + 1}. ${error}`);
                });
                console.warn(`\næˆåŠŸç‡ï¼š${pluginDetails.length}/${pluginsToProcess.length} (${Math.round(pluginDetails.length / pluginsToProcess.length * 100)}%)`);
              } else {
                console.log(`\nğŸ‰ æ‰€æœ‰æ’ä»¶å¤„ç†æˆåŠŸï¼`);
              }

            } catch (error) {
              console.error(`âŒ å¤„ç†å¤±è´¥ï¼š${error.message}`);
              process.exit(1);
            }
          }

          async function fetchManifest(repoUrl) {
            console.log(`\nğŸ” å¼€å§‹ä¸º ${repoUrl} è·å–æ¸…å•...`);
            const branches = ['main', 'master'];
            const filePaths = ['__init__.py', 'src/__init__.py', 'app/__init__.py']; // å¸¸è§è·¯å¾„

            for (const branch of branches) {
              for (const path of filePaths) {
                const rawUrl = repoUrl.replace('github.com', 'raw.githubusercontent.com') + `/${branch}/${path}`;
                console.log(`å°è¯•ä» ${branch} åˆ†æ”¯çš„ ${path} è·å–å…ƒæ•°æ®ï¼š${rawUrl}`);
                
                try {
                  const fileContent = await fetchFileContent(rawUrl);
                  const metadata = parseMetadata(fileContent);
                  if (metadata) {
                    console.log(`âœ… æˆåŠŸä» ${branch} åˆ†æ”¯çš„ ${path} è·å–åˆ°å…ƒæ•°æ®`);
                    return metadata;
                  }
                } catch (error) {
                  console.log(`âŒ åœ¨ ${branch} åˆ†æ”¯çš„ ${path} è·å–å¤±è´¥: ${error.message}`);
                }
              }
            }

            console.error(`âŒ åœ¨æ‰€æœ‰é¢„è®¾è·¯å¾„å’Œåˆ†æ”¯ä¸­éƒ½æœªèƒ½æ‰¾åˆ° ${repoUrl} çš„æœ‰æ•ˆå…ƒæ•°æ®ã€‚`);
            throw new Error(`æ— æ³•ä»ä»»ä½•åˆ†æ”¯æˆ–è·¯å¾„è·å–æœ‰æ•ˆçš„ __plugin_meta__ã€‚è¯·æ£€æŸ¥ä»“åº“ç»“æ„å’Œæ–‡ä»¶å†…å®¹ã€‚ä»“åº“åœ°å€ï¼š${repoUrl}`);
          }

          function fetchFileContent(url) {
            return new Promise((resolve, reject) => {
              console.log(`[GET] -> æ­£åœ¨è¯·æ±‚ URL: ${url}`);
              const req = https.get(url, res => {
                if (res.statusCode !== 200) {
                  console.error(`[${res.statusCode}] <- è¯·æ±‚ ${url} å¤±è´¥ã€‚`);
                  return reject(new Error(`çŠ¶æ€ç ï¼š${res.statusCode}`));
                }
                console.log(`[200 OK] <- æ”¶åˆ°æ¥è‡ª ${url} çš„æˆåŠŸå“åº”ã€‚`);
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
                res.on('error', err => {
                  console.error(`è¯»å–å“åº”æ•°æ®æ—¶å‡ºé”™: ${err.message}`);
                  reject(new Error(`è¯»å–å“åº”æ•°æ®æ—¶å‡ºé”™ï¼š${err.message}`));
                });
              });
              req.on('error', err => {
                console.error(`ç½‘ç»œé”™è¯¯: ${err.message}`);
                reject(new Error(`ç½‘ç»œé”™è¯¯ï¼š${err.message}`));
              });
              req.setTimeout(10000, () => {
                console.error(`è¯·æ±‚è¶…æ—¶: ${url}`);
                req.destroy();
                reject(new Error(`è¯·æ±‚è¶…æ—¶`));
              });
            });
          }
          
          function parseMetadata(content) {
            console.log('  [è°ƒè¯•] å¼€å§‹è§£æ __plugin_meta__ å†…å®¹...,ä¼ å…¥å†…å®¹:', content);
            // é˜¶æ®µ 1: åŒ¹é… PluginMetadata æ‹¬å·å†…çš„å®Œæ•´å†…å®¹
            const match = content.match(/__plugin_meta__\s*=\s*PluginMetadata\s*\(([\s\S]*?)\)/);
            if (!match || !match[1]) {
              console.log('  [è°ƒè¯•] æœªæ‰¾åˆ° __plugin_meta__ åŒ¹é…é¡¹ã€‚');
              return null;
            }
            console.log('  [è°ƒè¯•] æˆåŠŸåŒ¹é…åˆ° __plugin_meta__ï¼Œå‡†å¤‡è§£æå†…éƒ¨å‚æ•°...');
            
            const metadataStr = match[1].trim();
            const json = {};
            
            // é˜¶æ®µ 2: é€è¡Œè§£æï¼Œå¤„ç†å¤šè¡Œå­—ç¬¦ä¸²
            const lines = metadataStr.split('\n').filter(line => line.trim().length > 0);
            let currentKey = null;
            let currentValue = '';
            let inMultilineString = false;
            let multilineQuote = '';

            for (const line of lines) {
                const trimmedLine = line.trim();

                // å¦‚æœåœ¨å¤šè¡Œå­—ç¬¦ä¸²å†…éƒ¨
                if (inMultilineString) {
                    currentValue += '\n' + line; // ä¿ç•™åŸå§‹ç¼©è¿›å’Œæ¢è¡Œ
                    if (trimmedLine.endsWith(multilineQuote)) {
                        console.log(`    [è°ƒè¯•] å¤šè¡Œå­—ç¬¦ä¸²ç»“æŸ: ${currentKey}`);
                        inMultilineString = false;
                        // ç§»é™¤é¦–å°¾çš„ä¸‰ä¸ªå¼•å·
                        json[currentKey] = currentValue.substring(multilineQuote.length, currentValue.lastIndexOf(multilineQuote)).trim();
                        currentKey = null;
                        currentValue = '';
                    }
                    continue;
                }

                // å°è¯•åŒ¹é… "key = value" ç»“æ„
                const assignmentMatch = trimmedLine.match(/^(\w+)\s*=\s*(.*)/);
                if (assignmentMatch) {
                    const [, key, value] = assignmentMatch;
                    const cleanedValue = value.replace(/,$/, '').trim(); // ç§»é™¤æœ«å°¾é€—å·

                    // æ£€æŸ¥æ˜¯å¦æ˜¯å¤šè¡Œå­—ç¬¦ä¸²çš„å¼€å§‹
                    if (cleanedValue.startsWith('"""') || cleanedValue.startsWith("'''")) {
                        inMultilineString = true;
                        multilineQuote = cleanedValue.slice(0, 3);
                        currentKey = key;
                        currentValue = cleanedValue; // ä»åŒ…å«å¼•å·å¼€å§‹
                        console.log(`    [è°ƒè¯•] æ£€æµ‹åˆ°å¤šè¡Œå­—ç¬¦ä¸²å¼€å§‹: ${key}`);
                        // å¤„ç†å•è¡Œæƒ…å†µä¸‹çš„å¤šè¡Œå­—ç¬¦ä¸²
                        if (cleanedValue.endsWith(multilineQuote) && cleanedValue.length > 5) {
                            inMultilineString = false;
                            json[key] = cleanedValue.slice(3, -3).trim();
                            console.log(`    [è°ƒè¯•] (å•è¡Œæ¨¡å¼) è§£ææˆåŠŸ: ${key} = "${json[key]}"`);
                            currentKey = null;
                            currentValue = '';
                        }
                    } else {
                        // æ™®é€šçš„å•è¡Œå­—ç¬¦ä¸²
                        json[key] = cleanedValue.replace(/^['"]|['"]$/g, '');
                        console.log(`    [è°ƒè¯•] è§£ææˆåŠŸ: ${key} = "${json[key]}"`);
                    }
                }
            }

            // é˜¶æ®µ 3: è¿”å›ç»“æœ
            if (Object.keys(json).length > 0) {
              console.log(`  [è°ƒè¯•] è§£æå®Œæˆï¼Œæœ€ç»ˆå¯¹è±¡: ${JSON.stringify(json, null, 2)}`);
              return json;
            } else {
              console.log('  [è°ƒè¯•] æœªèƒ½ä» __plugin_meta__ ä¸­è§£æå‡ºä»»ä½•é”®å€¼å¯¹ã€‚å¯èƒ½æ˜¯æ ¼å¼é—®é¢˜ã€‚');
              return null;
            }
          }

          main();
          EOL

      - name: Commit and push plugin details
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add plugin_details.json
          if git diff --staged --quiet; then
            echo "æ²¡æœ‰å˜æ›´éœ€è¦æäº¤"
          else
            git commit -m "${{ steps.generate.outputs.commit_message }}"
            git push https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git HEAD:main
            echo "âœ… å·²æäº¤å¹¶æ¨é€ plugin_details.json æ›´æ–°"
          fi
